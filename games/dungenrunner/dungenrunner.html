<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <title>Dungeon Runner ‚Äì ≈°koln√≠ verze</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #222 0, #050608 60%);
      color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      margin-top: 20px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
    }

    #menu, #game {
      max-width: 900px;
      width: 100%;
      padding: 20px;
      box-sizing: border-box;
    }

    #menu {
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }

    label {
      display: block;
      margin: 10px 0 4px;
      font-weight: 600;
    }

    select, button {
      font-size: 16px;
      padding: 8px 10px;
      border-radius: 6px;
      border: none;
      margin-bottom: 10px;
    }

    button {
      cursor: pointer;
      font-weight: 700;
    }

    button#startGame {
      margin-top: 10px;
      background: #4caf50;
      color: white;
    }

    button#startGame:hover {
      filter: brightness(1.1);
    }

    .hidden {
      display: none;
    }

    #hud {
      display: flex;
      justify-content: space-between;
      gap: 15px;
      flex-wrap: wrap;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 10px;
      margin-bottom: 10px;
    }

    #hud span {
      white-space: nowrap;
    }

    #controls {
      font-size: 14px;
      margin-bottom: 10px;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 8px;
    }

    #mainRow {
      display: flex;
      gap: 12px;
      align-items: flex-start;
    }

    #grid {
      display: grid;
      grid-template-columns: repeat(10, 40px);
      grid-template-rows: repeat(10, 40px);
      gap: 3px;
      margin-top: 10px;
      background: #111;
      padding: 6px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }

    .tile {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: #1c1c1c;
      font-size: 22px;
      user-select: none;
    }

    .tile.player {
      background: #264653;
    }

    .tile.monster {
      background: #8d2b2b;
    }

    .tile.chest {
      background: #8c6b2f;
    }

    .tile.exit {
      background: #205c20;
    }

    .tile.wall {
      background: #444;
    }

    .tile.empty {
      background: #181818;
      color: #444;
      font-size: 14px;
    }

    #sideColumn {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
    }

    #log {
      max-height: 180px;
      overflow-y: auto;
      font-size: 13px;
      background: rgba(0,0,0,0.7);
      padding: 8px 12px;
      border-radius: 8px;
    }

    #log p {
      margin: 2px 0;
    }

    #inventory {
      font-size: 13px;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 8px;
      max-height: 140px;
      overflow-y: auto;
    }

    #inventory h3 {
      margin: 0 0 4px;
      font-size: 14px;
    }

    #inventory ul {
      margin: 0;
      padding-left: 16px;
    }

    #inventory li {
      margin-bottom: 2px;
    }

    #gameOverOverlay,
    #shopOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: white;
      z-index: 10;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    #gameOverOverlay button,
    #shopOverlay button {
      margin-top: 10px;
      background: #4caf50;
      color: white;
    }

    #shopItems {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 12px 0;
      max-width: 300px;
      width: 100%;
    }

    #shopItems button {
      width: 100%;
      background: #333;
    }
  </style>
</head>
<body>
  <h1>Dungeon Runner ‚Äì ≈°koln√≠ verze</h1>

  <!-- MENU: volba rasy+t≈ô√≠dy v jednom -->
  <section id="menu">
    <p>Jednoduch√Ω dungeon, kde si ≈æ√°ci procviƒç√≠ ovl√°d√°n√≠ kl√°vesnice (WASD, ≈°ipky, mezern√≠k, ƒç√≠sla).</p>

    <label for="raceSelect">Postava</label>
    <select id="raceSelect">
      <option value="human">ƒålovƒõk ‚Äì M√°g (mana, √∫tok na d√°lku)</option>
      <option value="elf">Elf ‚Äì Luƒçi≈°tn√≠k (≈°√≠py, √∫tok na d√°lku)</option>
      <option value="dwarf">Trpasl√≠k ‚Äì V√°leƒçn√≠k (lep≈°√≠ zbroj)</option>
      <option value="hobbit">Hobit ‚Äì Zlodƒõj (v√≠c zlata z lupu)</option>
    </select>

    <button id="startGame">Start hry</button>
  </section>

  <!-- HRA -->
  <section id="game" class="hidden">
    <div id="hud">
      <span id="hudLevel"></span>
      <span id="hudClassRace"></span>
      <span id="hudHp"></span>
      <span id="hudAttack"></span>
      <span id="hudWeapon"></span>
      <span id="hudGold"></span>
      <span id="hudResource"></span>
      <span id="hudKeys"></span>
    </div>

    <div id="controls">
      <strong>Ovl√°d√°n√≠:</strong>
      Pohyb: WASD nebo ≈°ipky | Bl√≠zk√Ω √∫tok: mezern√≠k (na sousedn√≠ monstrum) | Ability 1: kl√°vesa 1 (mal√© l√©ƒçen√≠) |  
      √ötok na d√°lku: kl√°vesa 2 ‚Äì <em>ƒålovƒõk (m√°g)</em> = kouzlo (mana), <em>Elf (luƒçi≈°tn√≠k)</em> = ≈°√≠py.  
      Ranged √∫tok automaticky c√≠l√≠ na nejbli≈æ≈°√≠ho nep≈ô√≠tele v ≈ôadƒõ/ sloupci ve vzd√°lenosti 2‚Äì4 pol√≠.  
      C√≠l: zabij v≈°echna monstra, posb√≠rej zlato a dojdi ke dve≈ô√≠m üö™. Dve≈ôe se otev≈ôou a≈æ po vyƒçi≈°tƒõn√≠ dungeonu.
    </div>

    <div id="mainRow">
      <div id="grid"></div>
      <div id="sideColumn">
        <div id="log"></div>
        <div id="inventory">
          <h3>Invent√°≈ô</h3>
          <ul id="inventoryList"></ul>
        </div>
      </div>
    </div>
  </section>

  <!-- Game over -->
  <div id="gameOverOverlay">
    <h2 id="gameOverText"></h2>
    <button id="restartBtn">Hr√°t znovu</button>
  </div>

  <!-- Obchod po levelu -->
  <div id="shopOverlay">
    <h2>Obchod mezi levely</h2>
    <p id="shopInfo"></p>
    <div id="shopItems">
      <button data-action="hp"></button>
      <button data-action="atk"></button>
      <button data-action="def"></button>
      <button data-action="heal"></button>
    </div>
    <button id="nextLevelBtn">Dal≈°√≠ level ‚ñ∂</button>
  </div>

  <script>
  // ==== Konstanta mapy ====
const mapWidth = 10;
const mapHeight = 10;
const VISION_RADIUS = 3; // kruh viditelnosti

// ==== Typy monster ====
const MONSTER_TYPES = [
  { name: 'Sliz',       hp: 10, attack: 3, symbol: 'üëæ' },
  { name: 'Kostlivec',  hp: 12, attack: 4, symbol: 'üíÄ' },
  { name: 'Netvor',     hp: 16, attack: 5, symbol: 'üëπ' }
];

const THIEF_GOLD_MULTIPLIER = 1.6; // Hobit/Zlodƒõj ‚Äì v√≠c zlata

// Itemy na zemi
const GROUND_ITEM_DEFS = [
  { kind: 'health', symbol: 'üíä', name: 'Lektvar zdrav√≠' },
  { kind: 'mana',   symbol: 'üîÆ', name: 'K≈ôi≈°≈•√°l many' },
  { kind: 'arrows', symbol: 'üèπ', name: 'Toulec ≈°√≠p≈Ø' },
  { kind: 'attack', symbol: 'üìú', name: 'Svitek s√≠ly' },
  { kind: 'gold',   symbol: 'üíé', name: 'Drahokam' }
];

// ==== Hr√°ƒç ====
const player = {
  x: 0,
  y: 9,
  maxHp: 1,
  hp: 1,
  baseAttack: 1,
  defense: 0,
  weaponBonus: 0,
  raceName: "",
  archetype: "",       // M√°g / Luƒçi≈°tn√≠k / V√°leƒçn√≠k / Zlodƒõj
  maxMana: 0,
  mana: 0,
  arrows: 0,
  facing: { dx: 1, dy: 0 },
  symbol: 'üßô',
  isThief: false,
  items: [],
  dodgeCharges: 5      // √∫skoky na level
};

let monsters = [];
let chests = [];
let walls = [];
let groundItems = [];
const exit = { x: 9, y: 0 };
let keyPressCount = 0;
let gameRunning = false;
let level = 1;
let gold = 0;

// vizu√°ln√≠ projektil
let projectilePath = [];
let projectileType = null; // "spell" nebo "arrow"

// ==== DOM prvky ====
const hudLevel      = document.getElementById('hudLevel');
const hudClassRace  = document.getElementById('hudClassRace');
const hudHp         = document.getElementById('hudHp');
const hudAttack     = document.getElementById('hudAttack');
const hudWeapon     = document.getElementById('hudWeapon');
const hudGold       = document.getElementById('hudGold');
const hudResource   = document.getElementById('hudResource');
const hudKeys       = document.getElementById('hudKeys');
const gridEl        = document.getElementById('grid');
const logEl         = document.getElementById('log');
const inventoryListEl = document.getElementById('inventoryList');
const menuEl        = document.getElementById('menu');
const gameEl        = document.getElementById('game');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const gameOverText  = document.getElementById('gameOverText');

const shopOverlay   = document.getElementById('shopOverlay');
const shopInfo      = document.getElementById('shopInfo');
const shopItems     = document.getElementById('shopItems');
const nextLevelBtn  = document.getElementById('nextLevelBtn');

// Dynamicky p≈ôid√°me smƒõrov√© ≈°ipky do HUDu
const hudContainer  = document.getElementById('hud');
const hudEnemyDir   = document.createElement('span');
const hudExitDir    = document.createElement('span');
hudContainer.appendChild(hudEnemyDir);
hudContainer.appendChild(hudExitDir);

// ==== Obchod ‚Äì inflace cen ====
const SHOP_INFLATION = 1.4;
const shopCosts = {
  hp: 10,
  atk: 10,
  def: 8,
  heal: 6,
  mana: 12,
  arrows: 10
};

// ==== Pomocn√© funkce ====
function log(msg) {
  const p = document.createElement('p');
  p.textContent = msg;
  logEl.appendChild(p);
  logEl.scrollTop = logEl.scrollHeight;
}

function updateInventory() {
  inventoryListEl.innerHTML = "";
  player.items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    inventoryListEl.appendChild(li);
  });
}

function addItem(desc) {
  player.items.push(desc);
  updateInventory();
}

function isSamePos(a, b) {
  return a.x === b.x && a.y === b.y;
}

function isWall(x, y) {
  return walls.some(w => w.x === x && w.y === y);
}

function getMonsterAt(x, y) {
  return monsters.find(m => m.hp > 0 && m.x === x && m.y === y);
}

function getChestAt(x, y) {
  return chests.find(c => !c.opened && c.x === x && c.y === y);
}

function getGroundItemAt(x, y) {
  return groundItems.find(it => it.x === x && it.y === y);
}

function removeGroundItem(item) {
  groundItems = groundItems.filter(it => it !== item);
}

// === smƒõrov√© ≈°ipky ===
function getDirectionIcon(dx, dy) {
  if (dx === 0 && dy < 0) return "‚Üë";
  if (dx === 0 && dy > 0) return "‚Üì";
  if (dx > 0 && dy === 0) return "‚Üí";
  if (dx < 0 && dy === 0) return "‚Üê";
  if (dx > 0 && dy < 0) return "‚Üó";
  if (dx < 0 && dy < 0) return "‚Üñ";
  if (dx > 0 && dy > 0) return "‚Üò";
  if (dx < 0 && dy > 0) return "‚Üô";
  return "-";
}

function randomFreePositions(count, forbiddenPositions) {
  const all = [];
  for (let y = 0; y < mapHeight; y++) {
    for (let x = 0; x < mapWidth; x++) {
      const forbidden = forbiddenPositions.some(p => p.x === x && p.y === y);
      if (!forbidden) {
        all.push({ x, y });
      }
    }
  }
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  return all.slice(0, count);
}

// chodba od startu ke dve≈ô√≠m
function buildPath(start, end) {
  const path = [];
  let x = start.x;
  let y = start.y;
  while (x !== end.x) {
    x += end.x > x ? 1 : -1;
    path.push({ x, y });
  }
  while (y !== end.y) {
    y += end.y > y ? 1 : -1;
    path.push({ x, y });
  }
  return path;
}

// Kontrola propojenosti cel√© mapy (bez zd√≠)
function isDungeonFullyConnected() {
  const visited = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(false));
  const q = [{ x: player.x, y: player.y }];
  visited[player.y][player.x] = true;

  const dirs = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 }
  ];

  while (q.length > 0) {
    const { x, y } = q.shift();
    for (const d of dirs) {
      const nx = x + d.dx;
      const ny = y + d.dy;
      if (nx < 0 || ny < 0 || nx >= mapWidth || ny >= mapHeight) continue;
      if (visited[ny][nx]) continue;
      if (isWall(nx, ny)) continue;
      visited[ny][nx] = true;
      q.push({ x: nx, y: ny });
    }
  }

  for (let y = 0; y < mapHeight; y++) {
    for (let x = 0; x < mapWidth; x++) {
      if (!isWall(x, y) && !visited[y][x]) {
        return false;
      }
    }
  }
  return true;
}

// Boss spawn helper ‚Äì naj√≠t voln√© pol√≠ƒçko pobl√≠≈æ dve≈ô√≠
function findFreeNearExit() {
  const candidates = [
    { x: exit.x - 1, y: exit.y },
    { x: exit.x, y: exit.y + 1 },
    { x: exit.x, y: exit.y - 1 },
    { x: exit.x - 1, y: exit.y + 1 },
    { x: exit.x - 1, y: exit.y - 1 }
  ];
  for (const c of candidates) {
    if (c.x < 0 || c.y < 0 || c.x >= mapWidth || c.y >= mapHeight) continue;
    if (isWall(c.x, c.y)) continue;
    if (getMonsterAt(c.x, c.y)) continue;
    return c;
  }
  return null;
}

function spawnBoss() {
  const pos = findFreeNearExit();
  if (!pos) return;
  const boss = {
    x: pos.x,
    y: pos.y,
    hp: 100 + level * 8,
    attack: 10 + Math.floor(level / 3),
    name: "Boss levelu " + level,
    symbol: "üëø",
    isBoss: true
  };
  monsters.push(boss);
}

// === generov√°n√≠ dungeonu jednoho pokusu ===
function generateDungeonLayout() {
  monsters = [];
  chests = [];
  walls = [];
  groundItems = [];
  projectilePath = [];
  projectileType = null;

  player.x = 0;
  player.y = 9;

  const baseForbidden = [{ x: player.x, y: player.y }, exit];

  const corridor = buildPath({ x: player.x, y: player.y }, exit);
  const forbiddenForWalls = baseForbidden.concat(corridor);

  const wallCount = Math.min(20, 6 + level * 2);
  const wallPositions = randomFreePositions(wallCount, forbiddenForWalls);
  walls = wallPositions;

  const forbidden = baseForbidden.concat(walls);

  const monsterCount = Math.min(12, 3 + level * 2);
  const chestCount   = 2 + Math.floor(level / 2);
  const itemCount    = 1 + Math.floor(level / 2);

  const totalNeeded = monsterCount + chestCount + itemCount;
  const positions = randomFreePositions(totalNeeded, forbidden);

  const monsterPositions = positions.slice(0, monsterCount);
  const chestPositions   = positions.slice(monsterCount, monsterCount + chestCount);
  const itemPositions    = positions.slice(monsterCount + chestCount);

  monsterPositions.forEach((pos, i) => {
    const type = MONSTER_TYPES[Math.floor(Math.random() * MONSTER_TYPES.length)];
    const extraHp = (level - 1) * 5;
    const extraAtk = Math.floor((level - 1) / 1.5) + 1;
    monsters.push({
      x: pos.x,
      y: pos.y,
      hp: type.hp + Math.max(0, extraHp),
      attack: type.attack + Math.max(0, extraAtk),
      name: `${type.name} ${i + 1}`,
      symbol: type.symbol
    });
  });

  chestPositions.forEach((pos, i) => {
    chests.push({
      x: pos.x,
      y: pos.y,
      opened: false,
      bonus: 2 + level + i,
      gold: 5 + level * 2 + i * 2
    });
  });

  itemPositions.forEach((pos, i) => {
    const def = GROUND_ITEM_DEFS[Math.floor(Math.random() * GROUND_ITEM_DEFS.length)];
    groundItems.push({
      x: pos.x,
      y: pos.y,
      kind: def.kind,
      symbol: def.symbol,
      name: def.name
    });
  });

  // Boss ka≈æd√Ωch 5 level≈Ø
  if (level % 5 === 0) {
    spawnBoss();
  }
}

function initDungeon() {
  let attempts = 0;
  do {
    attempts++;
    generateDungeonLayout();
    if (attempts > 20) break; // fail-safe
  } while (!isDungeonFullyConnected());

  logEl.innerHTML = "";
  log(`Vstoupil jsi do dungeon runneru ‚Äì level ${level}. Zabij v≈°echna monstra a pak dojdi ke dve≈ô√≠m.`);
}

// Ikonka podle povol√°n√≠
function updatePlayerSymbol() {
  if (player.archetype === 'M√°g') {
    player.symbol = 'üßô';
  } else if (player.archetype === 'Luƒçi≈°tn√≠k') {
    player.symbol = 'üèπ';
  } else if (player.archetype === 'V√°leƒçn√≠k') {
    player.symbol = 'üõ°Ô∏è';
  } else if (player.archetype === 'Zlodƒõj') {
    player.symbol = 'üó°Ô∏è';
  } else {
    player.symbol = 'üßë';
  }
}

function updateHud() {
  hudLevel.textContent = `Level: ${level}`;
  hudClassRace.textContent = `Postava: ${player.raceName} ‚Äì ${player.archetype}`;
  hudHp.textContent = `≈Ωivoty: ${player.hp}/${player.maxHp}`;
  const totalAttack = player.baseAttack + player.weaponBonus;
  hudAttack.textContent = `√ötok: ${totalAttack} (z√°kl. ${player.baseAttack}, zbra≈à +${player.weaponBonus})`;
  hudWeapon.textContent = player.weaponBonus > 0 ? `Zbra≈à: vylep≈°en√°` : `Zbra≈à: z√°kladn√≠`;
  hudGold.textContent = `Zlato: ${gold}`;

  let resText = '';
  if (player.archetype === 'M√°g') {
    resText = `Mana: ${player.mana}/${player.maxMana}`;
  } else if (player.archetype === 'Luƒçi≈°tn√≠k') {
    resText = `≈†√≠py: ${player.arrows}`;
  }
  if (resText) resText += " | ";
  resText += `√öskoky: ${player.dodgeCharges}`;
  hudResource.textContent = resText;

  hudKeys.textContent = `Stisknut√© kl√°vesy: ${keyPressCount}`;

  // smƒõr k nejbli≈æ≈°√≠mu nep≈ô√≠teli
  let nearest = null;
  monsters.forEach(m => {
    if (m.hp <= 0) return;
    const dx = m.x - player.x;
    const dy = m.y - player.y;
    const dist2 = dx * dx + dy * dy;
    if (!nearest || dist2 < nearest.dist2) {
      nearest = { dx, dy, dist2 };
    }
  });
  if (nearest) {
    hudEnemyDir.textContent = "Nep≈ô√≠tel: " + getDirectionIcon(Math.sign(nearest.dx), Math.sign(nearest.dy));
  } else {
    hudEnemyDir.textContent = "Nep≈ô√≠tel: -";
  }

  // smƒõr k dve≈ô√≠m
  const dxE = exit.x - player.x;
  const dyE = exit.y - player.y;
  hudExitDir.textContent = "Dve≈ôe: " + getDirectionIcon(Math.sign(dxE), Math.sign(dyE));
}

// Fog of war + render
function renderGrid() {
  gridEl.innerHTML = "";
  for (let y = 0; y < mapHeight; y++) {
    for (let x = 0; x < mapWidth; x++) {
      const tile = document.createElement('div');
      tile.classList.add('tile');

      let char = '';
      let extraClass = 'empty';

      const dxv = x - player.x;
      const dyv = y - player.y;
      const dist2 = dxv * dxv + dyv * dyv;
      const visible = dist2 <= VISION_RADIUS * VISION_RADIUS;

      if (player.x === x && player.y === y) {
        char = player.symbol;
        extraClass = 'player';
      } else if (isWall(x, y)) {
        char = 'üß±';
        extraClass = 'wall';
      } else {
        const m = getMonsterAt(x, y);
        const c = getChestAt(x, y);
        const item = getGroundItemAt(x, y);

        if (m) {
          char = m.symbol;
          extraClass = 'monster';
        } else if (c) {
          char = 'üí∞';
          extraClass = 'chest';
        } else if (item) {
          char = item.symbol;
          extraClass = 'chest';
        } else if (exit.x === x && exit.y === y) {
          char = 'üö™';
          extraClass = 'exit';
        } else {
          char = '.';
          extraClass = 'empty';
        }
      }

      if (!(player.x === x && player.y === y) &&
          projectilePath.some(p => p.x === x && p.y === y)) {
        char = projectileType === 'spell' ? '‚úß' : '‚û§';
      }

      if (!visible && !(player.x === x && player.y === y)) {
        tile.textContent = " ";
        tile.style.opacity = 0.15;
      } else {
        tile.textContent = char;
      }

      tile.classList.add(extraClass);
      gridEl.appendChild(tile);
    }
  }
}

function endGame(text) {
  gameRunning = false;
  gameOverText.textContent = text;
  gameOverOverlay.style.display = 'flex';
}

// ==== pathfinding pro monstra (BFS) ====
function findNextStepTowards(start, goal) {
  if (start.x === goal.x && start.y === goal.y) return null;

  const dirs = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 }
  ];

  const visited = Array.from({ length: mapHeight }, () =>
    Array(mapWidth).fill(false)
  );

  const queue = [];
  queue.push({ x: start.x, y: start.y });
  visited[start.y][start.x] = true;

  const parents = {};
  const key = (x, y) => `${x},${y}`;

  while (queue.length > 0) {
    const current = queue.shift();
    if (current.x === goal.x && current.y === goal.y) {
      let k = key(current.x, current.y);
      let prev = parents[k];
      let child = { x: current.x, y: current.y };
      while (prev && !(prev.x === start.x && prev.y === start.y)) {
        child = prev;
        k = key(prev.x, prev.y);
        prev = parents[k];
      }
      return child;
    }

    for (const d of dirs) {
      const nx = current.x + d.dx;
      const ny = current.y + d.dy;
      if (nx < 0 || nx >= mapWidth || ny < 0 || ny >= mapHeight) continue;
      if (visited[ny][nx]) continue;
      if (isWall(nx, ny)) continue;

      const occupied = monsters.some(m => m.hp > 0 &&
        !(m.x === start.x && m.y === start.y) &&
        m.x === nx && m.y === ny);
      if (occupied) continue;

      visited[ny][nx] = true;
      parents[key(nx, ny)] = { x: current.x, y: current.y };
      queue.push({ x: nx, y: ny });
    }
  }
  return null;
}

// ==== logika item≈Ø na zemi ====
function applyGroundItem(item) {
  if (item.kind === 'health') {
    const heal = 8;
    const before = player.hp;
    player.hp = Math.min(player.maxHp, player.hp + heal);
    const real = player.hp - before;
    log(`Vypil jsi lektvar zdrav√≠ (+${real} HP).`);
    addItem(`Lektvar zdrav√≠: +${real} HP`);
  } else if (item.kind === 'mana') {
    if (player.archetype === 'M√°g') {
      player.maxMana += 2;
      player.mana = Math.min(player.maxMana, player.mana + 4);
      log(`K≈ôi≈°≈•√°l many: max mana +2, mana +4.`);
      addItem(`K≈ôi≈°≈•√°l many: max+2, +4 mana`);
    } else {
      const bonus = 5 + Math.floor(Math.random() * 6);
      gold += bonus;
      log(`K≈ôi≈°≈•√°l many prod√°v√°≈° ‚Äì z√≠sk√°v√°≈° ${bonus} zlata.`);
      addItem(`Prodan√Ω k≈ôi≈°≈•√°l many: ${bonus} zlata`);
    }
  } else if (item.kind === 'arrows') {
    if (player.archetype === 'Luƒçi≈°tn√≠k') {
      player.arrows += 4;
      log(`Na≈°el jsi toulec ≈°√≠p≈Ø (+4 ≈°√≠py).`);
      addItem(`Toulec: +4 ≈°√≠py`);
    } else {
      const bonus = 5 + Math.floor(Math.random() * 6);
      gold += bonus;
      log(`Toulec prod√°v√°≈° ‚Äì ${bonus} zlata.`);
      addItem(`Prodan√Ω toulec: ${bonus} zlata`);
    }
  } else if (item.kind === 'attack') {
    player.baseAttack += 1;
    log(`Svitek s√≠ly: tv≈Øj z√°kladn√≠ √∫tok se zvy≈°uje o +1.`);
    addItem(`Svitek s√≠ly: +1 z√°kladn√≠ √∫tok`);
  } else if (item.kind === 'gold') {
    let bonus = 8 + Math.floor(Math.random() * 8);
    if (player.isThief) bonus = Math.round(bonus * THIEF_GOLD_MULTIPLIER);
    gold += bonus;
    log(`Na≈°el jsi drahokam: ${bonus} zlata.`);
    addItem(`Drahokam: ${bonus} zlata`);
  }
  updateHud();
}

// ==== Pohyb a melee √∫tok ====
function tryMove(dx, dy) {
  if (!gameRunning) return;
  const newX = player.x + dx;
  const newY = player.y + dy;

  if (newX < 0 || newX >= mapWidth || newY < 0 || newY >= mapHeight) {
    log("Narazil jsi do okraje dungeonu.");
    return;
  }

  if (isWall(newX, newY)) {
    log("Nar√°≈æ√≠≈° do zdi.");
    return;
  }

  const monster = getMonsterAt(newX, newY);
  if (monster) {
    attackMonster(monster);
    return;
  }

  player.x = newX;
  player.y = newY;
  if (dx !== 0 || dy !== 0) {
    player.facing = { dx, dy };
  }
  log(`Posunul ses na (${player.x + 1}, ${player.y + 1}).`);

  const chest = getChestAt(player.x, player.y);
  if (chest) {
    chest.opened = true;
    player.weaponBonus += chest.bonus;
    let goldGain = chest.gold;
    if (player.isThief) {
      goldGain = Math.round(goldGain * THIEF_GOLD_MULTIPLIER);
    }
    gold += goldGain;
    log(`Na≈°el jsi truhlu! Zbra≈à pos√≠lena o +${chest.bonus} √∫toku a z√≠sk√°v√°≈° ${goldGain} zlata.`);
    addItem(`Truhla: +${chest.bonus} √∫toku, ${goldGain} zlata`);
  }

  const item = getGroundItemAt(player.x, player.y);
  if (item) {
    applyGroundItem(item);
    removeGroundItem(item);
  }

  updateHud();
  renderGrid();

  if (isSamePos(player, exit)) {
    const alive = monsters.some(m => m.hp > 0);
    if (alive) {
      log("Dve≈ôe jsou zamƒçen√©, dokud v dungeonu z≈Øst√°vaj√≠ monstra.");
    } else {
      log("Do≈°el jsi ke dve≈ô√≠m ‚Äì level dokonƒçen!");
      gameRunning = false;
      openShop();
      return;
    }
  }

  monstersAct();
}

// √öskok / sprint o 2 pol√≠ƒçka, monstra netahaj√≠
function dodgeMove(dx, dy) {
  if (!gameRunning) return;
  if (player.dodgeCharges <= 0) {
    log("Do≈°ly ti √∫skoky!");
    return;
  }
  const nx = player.x + dx * 2;
  const ny = player.y + dy * 2;
  if (nx < 0 || nx >= mapWidth || ny < 0 || ny >= mapHeight) {
    log("Nem≈Ø≈æe≈° uhnout mimo mapu.");
    return;
  }
  if (isWall(nx, ny)) {
    log("√öskok blokuje zeƒè.");
    return;
  }
  const monster = getMonsterAt(nx, ny);
  if (monster) {
    log("Nem≈Ø≈æe≈° skoƒçit p≈ô√≠mo na monstrum.");
    return;
  }

  player.x = nx;
  player.y = ny;
  player.facing = { dx, dy };
  player.dodgeCharges--;
  log(`√öskok! Zb√Ωv√° √∫skok≈Ø: ${player.dodgeCharges}.`);

  const item = getGroundItemAt(player.x, player.y);
  if (item) {
    applyGroundItem(item);
    removeGroundItem(item);
  }

  updateHud();
  renderGrid();
}

// Odmƒõna za kill
function rewardGoldForKill(name) {
  let gain = 5 + Math.floor(Math.random() * 6) + level * 2;
  if (player.isThief) {
    gain = Math.round(gain * THIEF_GOLD_MULTIPLIER);
  }
  gold += gain;
  log(`${name} byl pora≈æen! Z√≠sk√°v√°≈° ${gain} zlata.`);
}

// Melee √∫tok
function attackMonster(monster) {
  if (!gameRunning) return;
  const totalAttack = player.baseAttack + player.weaponBonus;
  log(`√ötoƒç√≠≈° na ${monster.name} a d√°v√°≈° ${totalAttack} po≈°kozen√≠.`);
  monster.hp -= totalAttack;

  if (monster.hp <= 0) {
    rewardGoldForKill(monster.name);
  } else {
    log(`${monster.name} m√° je≈°tƒõ ${monster.hp} HP.`);
  }

  monstersAct();
  updateHud();
  renderGrid();
}

// Tah monster
function monstersAct() {
  if (!gameRunning) return;
  monsters.forEach(m => {
    if (m.hp <= 0) return;

    const dx = player.x - m.x;
    const dy = player.y - m.y;
    const distance = Math.abs(dx) + Math.abs(dy);

    if (distance === 1) {
      const raw = m.attack - Math.floor(player.defense * 0.6);
      const dmg = Math.max(1, raw);
      player.hp -= dmg;
      log(`${m.name} tƒõ zas√°hl za ${dmg} po≈°kozen√≠!`);
      if (player.hp <= 0) {
        player.hp = 0;
        updateHud();
        endGame("Zem≈ôel jsi v dungeonu. :(");
      }
    } else {
      const nextStep = findNextStepTowards({ x: m.x, y: m.y }, { x: player.x, y: player.y });
      if (nextStep) {
        const occupied = monsters.some(other => other !== m && other.hp > 0 &&
          other.x === nextStep.x && other.y === nextStep.y);
        if (!occupied && !(player.x === nextStep.x && player.y === nextStep.y)) {
          m.x = nextStep.x;
          m.y = nextStep.y;
        }
      }
    }
  });
  updateHud();
  renderGrid();
}

// Ability 1 ‚Äì mal√© l√©ƒçen√≠
function useAbility1() {
  if (!gameRunning) return;
  const heal = 4;
  if (player.hp >= player.maxHp) {
    log("Ability 1: U≈æ m√°≈° pln√© ≈æivoty.");
    return;
  }
  player.hp = Math.min(player.maxHp, player.hp + heal);
  log(`Ability 1: L√©ƒç√≠≈° se o ${heal} HP.`);
  updateHud();
}

// line-of-sight pro ranged
function hasLineOfSightTo(target) {
  if (target.x !== player.x && target.y !== player.y) return false;
  let dx = 0, dy = 0;
  if (target.x > player.x) dx = 1;
  else if (target.x < player.x) dx = -1;
  if (target.y > player.y) dy = 1;
  else if (target.y < player.y) dy = -1;

  let x = player.x + dx;
  let y = player.y + dy;
  while (!(x === target.x && y === target.y)) {
    if (isWall(x, y)) return false;
    x += dx;
    y += dy;
  }
  return true;
}

// Nejbli≈æ≈°√≠ c√≠l pro ranged (2‚Äì4 pol√≠, ≈ôada/sloupec)
function findRangedTarget(maxRange = 4) {
  let best = null;
  monsters.forEach(m => {
    if (m.hp <= 0) return;
    if (m.x !== player.x && m.y !== player.y) return;
    const dist = Math.abs(m.x - player.x) + Math.abs(m.y - player.y);
    if (dist < 2 || dist > maxRange) return;
    if (!hasLineOfSightTo(m)) return;
    if (!best || dist < best.dist) {
      let dx = 0, dy = 0;
      if (m.x > player.x) dx = 1;
      else if (m.x < player.x) dx = -1;
      if (m.y > player.y) dy = 1;
      else if (m.y < player.y) dy = -1;
      best = { monster: m, dx, dy, dist };
    }
  });
  return best;
}

// √ötok na d√°lku ‚Äì auto-target
function useRangedAttack() {
  if (!gameRunning) return;

  let dmg;
  let type = null;

  if (player.archetype === 'M√°g') {
    const cost = 3;
    if (player.mana < cost) {
      log("Nem√°≈° dost many na kouzlo na d√°lku.");
      return;
    }
    player.mana -= cost;
    dmg = player.baseAttack + player.weaponBonus + 4;
    type = 'spell';
    log("Ses√≠l√°≈° kouzlo na d√°lku.");
  } else if (player.archetype === 'Luƒçi≈°tn√≠k') {
    const cost = 1;
    if (player.arrows < cost) {
      log("Do≈°ly ti ≈°√≠py.");
      return;
    }
    player.arrows -= cost;
    dmg = player.baseAttack + player.weaponBonus + 3;
    type = 'arrow';
    log("Vyst≈ôelil jsi ≈°√≠p.");
  } else {
    log("Tvoje postava nem√° √∫tok na d√°lku.");
    return;
  }

  const targetInfo = findRangedTarget(4);
  if (!targetInfo) {
    log("V dosahu (2‚Äì4 pol√≠ v ≈ôadƒõ/sloupci) nen√≠ ≈æ√°dn√Ω c√≠l.");
    updateHud();
    return;
  }

  const { monster: target, dx, dy, dist } = targetInfo;

  let x = player.x + dx;
  let y = player.y + dy;
  let pathCells = [];

  for (let step = 1; step <= dist; step++) {
    pathCells.push({ x, y });
    x += dx;
    y += dy;
  }

  projectilePath = pathCells;
  projectileType = type;
  updateHud();
  renderGrid();

  gameRunning = false;

  setTimeout(() => {
    log(`√ötok na d√°lku zasahuje ${target.name} za ${dmg} po≈°kozen√≠.`);
    target.hp -= dmg;
    if (target.hp <= 0) {
      rewardGoldForKill(target.name);
    } else {
      log(`${target.name} m√° je≈°tƒõ ${target.hp} HP.`);
    }

    projectilePath = [];
    projectileType = null;
    updateHud();
    renderGrid();

    gameRunning = true;
    monstersAct();
  }, 180);
}

// ==== Obchod ====
function updateShopButtons() {
  shopItems.querySelectorAll('button').forEach(btn => {
    const action = btn.dataset.action;
    if (action === 'hp') {
      btn.textContent = `+5 max HP (${shopCosts.hp} zlata)`;
    } else if (action === 'atk') {
      btn.textContent = `+2 z√°kladn√≠ √∫tok (${shopCosts.atk} zlata)`;
    } else if (action === 'def') {
      btn.textContent = `+ obrana (cena ${shopCosts.def} zlata)`;
    } else if (action === 'heal') {
      btn.textContent = `Vyl√©ƒçit na pln√© HP (${shopCosts.heal} zlata)`;
    } else if (action === 'mana') {
      btn.textContent = `+3 max many (M√°g) (${shopCosts.mana} zlata)`;
    } else if (action === 'arrows') {
      btn.textContent = `+3 ≈°√≠py (Luƒçi≈°tn√≠k) (${shopCosts.arrows} zlata)`;
    }
  });
}

function openShop() {
  shopInfo.textContent = `Level ${level} dokonƒçen. M√°≈° ${gold} zlata. Vyber si vylep≈°en√≠ nebo pokraƒçuj d√°l.`;
  updateShopButtons();
  shopOverlay.style.display = 'flex';
  updateHud();
}

shopItems.addEventListener('click', (e) => {
  if (e.target.tagName !== 'BUTTON') return;
  const action = e.target.dataset.action;
  let cost = 0;

  if (action === 'hp') {
    cost = shopCosts.hp;
    if (gold >= cost) {
      gold -= cost;
      player.maxHp += 5;
      player.hp += 5;
      shopCosts.hp = Math.round(shopCosts.hp * SHOP_INFLATION);
      log("Kupuje≈°: +5 max HP (cena p≈ô√≠≈°tƒõ vy≈°≈°√≠).");
      addItem("+5 max HP (obchod)");
    } else {
      log("Nem√°≈° dost zlata na +5 max HP.");
    }
  } else if (action === 'atk') {
    cost = shopCosts.atk;
    if (gold >= cost) {
      gold -= cost;
      player.baseAttack += 2;
      shopCosts.atk = Math.round(shopCosts.atk * SHOP_INFLATION);
      log("Kupuje≈°: +2 z√°kladn√≠ √∫tok (cena p≈ô√≠≈°tƒõ vy≈°≈°√≠).");
      addItem("+2 z√°kladn√≠ √∫tok (obchod)");
    } else {
      log("Nem√°≈° dost zlata na +2 √∫tok.");
    }
  } else if (action === 'def') {
    cost = shopCosts.def;
    if (gold >= cost) {
      gold -= cost;
      const bonus = (player.archetype === 'V√°leƒçn√≠k') ? 2 : 1;
      player.defense += bonus;
      shopCosts.def = Math.round(shopCosts.def * SHOP_INFLATION);
      log(`Kupuje≈°: +${bonus} obrana (cena p≈ô√≠≈°tƒõ vy≈°≈°√≠).`);
      addItem(`+${bonus} obrana (obchod)`);
    } else {
      log("Nem√°≈° dost zlata na obranu.");
    }
  } else if (action === 'heal') {
    cost = shopCosts.heal;
    if (gold >= cost) {
      gold -= cost;
      player.hp = player.maxHp;
      shopCosts.heal = Math.round(shopCosts.heal * SHOP_INFLATION);
      log("Kupuje≈°: pln√© l√©ƒçen√≠ (cena p≈ô√≠≈°tƒõ vy≈°≈°√≠).");
    } else {
      log("Nem√°≈° dost zlata na l√©ƒçen√≠.");
    }
  } else if (action === 'mana') {
    cost = shopCosts.mana;
    if (player.archetype !== 'M√°g') {
      log("Toto vylep≈°en√≠ je jen pro M√°ga.");
    } else if (gold >= cost) {
      gold -= cost;
      player.maxMana += 3;
      player.mana += 3;
      shopCosts.mana = Math.round(shopCosts.mana * SHOP_INFLATION);
      log("Kupuje≈°: +3 max many (M√°g).");
      addItem("+3 max many (obchod)");
    } else {
      log("Nem√°≈° dost zlata na many.");
    }
  } else if (action === 'arrows') {
    cost = shopCosts.arrows;
    if (player.archetype !== 'Luƒçi≈°tn√≠k') {
      log("Toto vylep≈°en√≠ je jen pro Luƒçi≈°tn√≠ka.");
    } else if (gold >= cost) {
      gold -= cost;
      player.arrows += 3;
      shopCosts.arrows = Math.round(shopCosts.arrows * SHOP_INFLATION);
      log("Kupuje≈°: +3 ≈°√≠py.");
      addItem("+3 ≈°√≠py (obchod)");
    } else {
      log("Nem√°≈° dost zlata na ≈°√≠py.");
    }
  }

  shopInfo.textContent = `Level ${level} dokonƒçen. M√°≈° ${gold} zlata.`;
  updateShopButtons();
  updateHud();
});

nextLevelBtn.addEventListener('click', () => {
  level += 1;
  player.hp = player.maxHp;
  if (player.archetype === 'M√°g') {
    player.mana = player.maxMana;
  }
  if (player.archetype === 'Luƒçi≈°tn√≠k') {
    player.arrows += 3;
  }
  player.dodgeCharges = 5;
  shopOverlay.style.display = 'none';
  startLevel();
});

// ==== Obsluha kl√°ves ====
window.addEventListener('keydown', (e) => {
  if (!gameRunning) return;

  keyPressCount++;
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',
       'w','W','a','A','s','S','d','D',' ','1','2'].includes(e.key)) {
    e.preventDefault();
  }

  // Nejprve zkus√≠me √∫skok (Shift + smƒõr)
  let dx = 0, dy = 0;
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
    dx = 0; dy = -1;
  } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
    dx = 0; dy = 1;
  } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
    dx = -1; dy = 0;
  } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
    dx = 1; dy = 0;
  }

  if (e.shiftKey && (dx !== 0 || dy !== 0)) {
    dodgeMove(dx, dy);
    updateHud();
    return;
  }

  switch (e.key) {
    case 'ArrowUp':
    case 'w':
    case 'W':
      tryMove(0, -1);
      break;
    case 'ArrowDown':
    case 's':
    case 'S':
      tryMove(0, 1);
      break;
    case 'ArrowLeft':
    case 'a':
    case 'A':
      tryMove(-1, 0);
      break;
    case 'ArrowRight':
    case 'd':
    case 'D':
      tryMove(1, 0);
      break;
    case '1':
      useAbility1();
      break;
    case '2':
      useRangedAttack();
      break;
    case ' ': {
      const neighbors = [
        { x: player.x + 1, y: player.y },
        { x: player.x - 1, y: player.y },
        { x: player.x, y: player.y + 1 },
        { x: player.x, y: player.y - 1 }
      ];
      const target = neighbors
        .map(pos => getMonsterAt(pos.x, pos.y))
        .find(m => m);
      if (target) {
        attackMonster(target);
      } else {
        log("≈Ω√°dn√© monstrum v dosahu √∫toku.");
      }
      break;
    }
  }
  updateHud();
});

// ==== Start levelu ====
function startLevel() {
  initDungeon();
  player.dodgeCharges = 5;
  updateHud();
  renderGrid();
  gameRunning = true;
}

// ==== Start hry z menu ====
document.getElementById('startGame').addEventListener('click', () => {
  const raceValue = document.getElementById('raceSelect').value;

  player.isThief = false;
  player.items = [];
  updateInventory();

  if (raceValue === 'human') {
    player.raceName = 'ƒålovƒõk';
    player.archetype = 'M√°g';
    player.maxHp = 20;
    player.baseAttack = 7;
    player.defense = 0;
    player.maxMana = 12;
    player.mana = 12;
    player.arrows = 0;
  } else if (raceValue === 'elf') {
    player.raceName = 'Elf';
    player.archetype = 'Luƒçi≈°tn√≠k';
    player.maxHp = 22;
    player.baseAttack = 6;
    player.defense = 0;
    player.maxMana = 0;
    player.mana = 0;
    player.arrows = 7;
  } else if (raceValue === 'dwarf') {
    player.raceName = 'Trpasl√≠k';
    player.archetype = 'V√°leƒçn√≠k';
    player.maxHp = 32;
    player.baseAttack = 6;
    player.defense = 3;
    player.maxMana = 0;
    player.mana = 0;
    player.arrows = 0;
  } else if (raceValue === 'hobbit') {
    player.raceName = 'Hobit';
    player.archetype = 'Zlodƒõj';
    player.maxHp = 24;
    player.baseAttack = 5;
    player.defense = 1;
    player.maxMana = 0;
    player.mana = 0;
    player.arrows = 0;
    player.isThief = true;
  }

  player.hp = player.maxHp;
  player.weaponBonus = 0;
  player.facing = { dx: 1, dy: 0 };
  player.dodgeCharges = 5;
  updatePlayerSymbol();

  level = 1;
  gold = 0;
  keyPressCount = 0;

  shopCosts.hp = 10;
  shopCosts.atk = 10;
  shopCosts.def = 8;
  shopCosts.heal = 6;
  shopCosts.mana = 12;
  shopCosts.arrows = 10;

  gameOverOverlay.style.display = 'none';
  shopOverlay.style.display = 'none';

  menuEl.classList.add('hidden');
  gameEl.classList.remove('hidden');

  startLevel();
});

document.getElementById('restartBtn').addEventListener('click', () => {
  gameOverOverlay.style.display = 'none';
  gameEl.classList.add('hidden');
  menuEl.classList.remove('hidden');
});
  </script>
</body>
</html>
