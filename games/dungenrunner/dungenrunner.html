<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <title>Dungeon Runner ‚Äì ≈°koln√≠ verze</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #222 0, #050608 60%);
      color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      margin-top: 20px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
    }

    #menu, #game {
      max-width: 900px;
      width: 100%;
      padding: 20px;
      box-sizing: border-box;
    }

    #menu {
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }

    label {
      display: block;
      margin: 10px 0 4px;
      font-weight: 600;
    }

    select, button {
      font-size: 16px;
      padding: 8px 10px;
      border-radius: 6px;
      border: none;
      margin-bottom: 10px;
    }

    button {
      cursor: pointer;
      font-weight: 700;
    }

    button#startGame {
      margin-top: 10px;
      background: #4caf50;
      color: white;
    }

    button#startGame:hover {
      filter: brightness(1.1);
    }

    .hidden {
      display: none;
    }

    #hud {
      display: flex;
      justify-content: space-between;
      gap: 15px;
      flex-wrap: wrap;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 10px;
      margin-bottom: 10px;
    }

    #hud span {
      white-space: nowrap;
    }

    #controls {
      font-size: 14px;
      margin-bottom: 10px;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 8px;
    }

    #mainRow {
      display: flex;
      gap: 12px;
      align-items: flex-start;
    }

    #grid {
      display: grid;
      grid-template-columns: repeat(10, 40px);
      grid-template-rows: repeat(10, 40px);
      gap: 3px;
      margin-top: 10px;
      background: #111;
      padding: 6px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }

    .tile {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: #1c1c1c;
      font-size: 22px;
      user-select: none;
    }

    .tile.player {
      background: #264653;
    }

    .tile.monster {
      background: #8d2b2b;
    }

    .tile.chest {
      background: #8c6b2f;
    }

    .tile.exit {
      background: #205c20;
    }

    .tile.wall {
      background: #444;
    }

    .tile.empty {
      background: #181818;
      color: #444;
      font-size: 14px;
    }

    #sideColumn {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
    }

    #log {
      max-height: 180px;
      overflow-y: auto;
      font-size: 13px;
      background: rgba(0,0,0,0.7);
      padding: 8px 12px;
      border-radius: 8px;
    }

    #log p {
      margin: 2px 0;
    }

    #inventory {
      font-size: 13px;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 8px;
      max-height: 140px;
      overflow-y: auto;
    }

    #inventory h3 {
      margin: 0 0 4px;
      font-size: 14px;
    }

    #inventory ul {
      margin: 0;
      padding-left: 16px;
    }

    #inventory li {
      margin-bottom: 2px;
    }

    #gameOverOverlay,
    #shopOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: white;
      z-index: 10;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }

    #gameOverOverlay button,
    #shopOverlay button {
      margin-top: 10px;
      background: #4caf50;
      color: white;
    }

    #shopItems {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 12px 0;
      max-width: 300px;
      width: 100%;
    }

    #shopItems button {
      width: 100%;
      background: #333;
    }
  </style>
</head>
<body>
  <h1>Dungeon Runner ‚Äì ≈°koln√≠ verze</h1>

  <!-- MENU: volba rasy+t≈ô√≠dy v jednom -->
  <section id="menu">
    <p>Jednoduch√Ω dungeon, kde si ≈æ√°ci procviƒç√≠ ovl√°d√°n√≠ kl√°vesnice (WASD, ≈°ipky, mezern√≠k, ƒç√≠sla).</p>

    <label for="raceSelect">Postava</label>
    <select id="raceSelect">
      <option value="human">ƒålovƒõk ‚Äì M√°g (mana, √∫tok na d√°lku)</option>
      <option value="elf">Elf ‚Äì Luƒçi≈°tn√≠k (≈°√≠py, √∫tok na d√°lku)</option>
      <option value="dwarf">Trpasl√≠k ‚Äì V√°leƒçn√≠k (lep≈°√≠ zbroj)</option>
      <option value="hobbit">Hobit ‚Äì Zlodƒõj (v√≠c zlata z lupu)</option>
    </select>

    <button id="startGame">Start hry</button>
  </section>

  <!-- HRA -->
  <section id="game" class="hidden">
    <div id="hud">
      <span id="hudLevel"></span>
      <span id="hudClassRace"></span>
      <span id="hudHp"></span>
      <span id="hudAttack"></span>
      <span id="hudWeapon"></span>
      <span id="hudGold"></span>
      <span id="hudResource"></span>
      <span id="hudKeys"></span>
    </div>

    <div id="controls">
      <strong>Ovl√°d√°n√≠:</strong>
      Pohyb: WASD nebo ≈°ipky | Bl√≠zk√Ω √∫tok: mezern√≠k (na sousedn√≠ monstrum) | Ability 1: kl√°vesa 1 (mal√© l√©ƒçen√≠) |  
      √ötok na d√°lku: kl√°vesa 2 ‚Äì <em>ƒålovƒõk (m√°g)</em> = kouzlo (mana), <em>Elf (luƒçi≈°tn√≠k)</em> = ≈°√≠py.  
      Ranged √∫tok automaticky c√≠l√≠ na nejbli≈æ≈°√≠ho nep≈ô√≠tele v ≈ôadƒõ/ sloupci ve vzd√°lenosti 2‚Äì4 pol√≠.  
      C√≠l: zabij v≈°echna monstra, posb√≠rej zlato a dojdi ke dve≈ô√≠m üö™. Dve≈ôe se otev≈ôou a≈æ po vyƒçi≈°tƒõn√≠ dungeonu.
    </div>

    <div id="mainRow">
      <div id="grid"></div>
      <div id="sideColumn">
        <div id="log"></div>
        <div id="inventory">
          <h3>Invent√°≈ô</h3>
          <ul id="inventoryList"></ul>
        </div>
      </div>
    </div>
  </section>

  <!-- Game over -->
  <div id="gameOverOverlay">
    <h2 id="gameOverText"></h2>
    <button id="restartBtn">Hr√°t znovu</button>
  </div>

  <!-- Obchod po levelu -->
  <div id="shopOverlay">
    <h2>Obchod mezi levely</h2>
    <p id="shopInfo"></p>
    <div id="shopItems">
      <button data-action="hp"></button>
      <button data-action="atk"></button>
      <button data-action="def"></button>
      <button data-action="heal"></button>
    </div>
    <button id="nextLevelBtn">Dal≈°√≠ level ‚ñ∂</button>
  </div>

  <script>
    // ==== Hern√≠ stav ====
    const mapWidth = 10;
    const mapHeight = 10;

    const MONSTER_TYPES = [
      { name: 'Sliz',       hp: 10, attack: 3, symbol: 'üëæ' },
      { name: 'Kostlivec',  hp: 12, attack: 4, symbol: 'üíÄ' },
      { name: 'Netvor',     hp: 16, attack: 5, symbol: 'üëπ' }
    ];

    const THIEF_GOLD_MULTIPLIER = 1.6; // hobit ‚Äì v√≠c zlata

    const player = {
      x: 0,
      y: 9,
      maxHp: 1,
      hp: 1,
      baseAttack: 1,
      defense: 0,
      weaponBonus: 0,
      raceName: "",
      archetype: "",       // M√°g / Luƒçi≈°tn√≠k / V√°leƒçn√≠k / Zlodƒõj
      maxMana: 0,
      mana: 0,
      arrows: 0,
      facing: { dx: 1, dy: 0 },
      symbol: 'üßô',
      isThief: false,
      items: []
    };

    let monsters = [];
    let chests = [];
    let walls = [];
    const exit = { x: 9, y: 0 }; // v√Ωchod
    let keyPressCount = 0;
    let gameRunning = false;
    let level = 1;
    let gold = 0;

    // vizu√°ln√≠ projektil
    let projectilePath = [];
    let projectileType = null; // "spell" nebo "arrow"

    const hudLevel   = document.getElementById('hudLevel');
    const hudClassRace = document.getElementById('hudClassRace');
    const hudHp      = document.getElementById('hudHp');
    const hudAttack  = document.getElementById('hudAttack');
    const hudWeapon  = document.getElementById('hudWeapon');
    const hudGold    = document.getElementById('hudGold');
    const hudResource = document.getElementById('hudResource');
    const hudKeys    = document.getElementById('hudKeys');
    const gridEl     = document.getElementById('grid');
    const logEl      = document.getElementById('log');
    const inventoryListEl = document.getElementById('inventoryList');
    const menuEl     = document.getElementById('menu');
    const gameEl     = document.getElementById('game');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const gameOverText    = document.getElementById('gameOverText');

    const shopOverlay = document.getElementById('shopOverlay');
    const shopInfo    = document.getElementById('shopInfo');
    const shopItems   = document.getElementById('shopItems');
    const nextLevelBtn = document.getElementById('nextLevelBtn');

    // ==== Obchod ‚Äì inflace cen ====
    const SHOP_INFLATION = 1.4;
    const shopCosts = {
      hp: 10,
      atk: 10,
      def: 8,
      heal: 6
    };

    function updateShopButtons() {
      shopItems.querySelectorAll('button').forEach(btn => {
        const action = btn.dataset.action;
        if (action === 'hp') {
          btn.textContent = `+5 max HP (${shopCosts.hp} zlata)`;
        } else if (action === 'atk') {
          btn.textContent = `+2 z√°kladn√≠ √∫tok (${shopCosts.atk} zlata)`;
        } else if (action === 'def') {
          btn.textContent = `+1 obrana (${shopCosts.def} zlata)`;
        } else if (action === 'heal') {
          btn.textContent = `Vyl√©ƒçit na pln√© HP (${shopCosts.heal} zlata)`;
        }
      });
    }

    // ==== Pomocn√© funkce ====
    function log(msg) {
      const p = document.createElement('p');
      p.textContent = msg;
      logEl.appendChild(p);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function updateInventory() {
      inventoryListEl.innerHTML = "";
      player.items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        inventoryListEl.appendChild(li);
      });
    }

    function addItem(desc) {
      player.items.push(desc);
      updateInventory();
    }

    function updateHud() {
      hudLevel.textContent = `Level: ${level}`;
      hudClassRace.textContent = `Postava: ${player.raceName} ‚Äì ${player.archetype}`;
      hudHp.textContent = `≈Ωivoty: ${player.hp}/${player.maxHp}`;
      const totalAttack = player.baseAttack + player.weaponBonus;
      hudAttack.textContent = `√ötok: ${totalAttack} (z√°kl. ${player.baseAttack}, zbra≈à +${player.weaponBonus})`;
      hudWeapon.textContent = player.weaponBonus > 0 ? `Zbra≈à: vylep≈°en√°` : `Zbra≈à: z√°kladn√≠`;
      hudGold.textContent = `Zlato: ${gold}`;

      let resText = '';
      if (player.archetype === 'M√°g') {
        resText = `Mana: ${player.mana}/${player.maxMana}`;
      } else if (player.archetype === 'Luƒçi≈°tn√≠k') {
        resText = `≈†√≠py: ${player.arrows}`;
      }
      hudResource.textContent = resText;

      hudKeys.textContent = `Stisknut√© kl√°vesy: ${keyPressCount}`;
    }

    function isSamePos(a, b) {
      return a.x === b.x && a.y === b.y;
    }

    function isWall(x, y) {
      return walls.some(w => w.x === x && w.y === y);
    }

    function getMonsterAt(x, y) {
      return monsters.find(m => m.hp > 0 && m.x === x && m.y === y);
    }

    function getChestAt(x, y) {
      return chests.find(c => !c.opened && c.x === x && c.y === y);
    }

    function randomFreePositions(count, forbiddenPositions) {
      const all = [];
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          const forbidden = forbiddenPositions.some(p => p.x === x && p.y === y);
          if (!forbidden) {
            all.push({ x, y });
          }
        }
      }
      for (let i = all.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [all[i], all[j]] = [all[j], all[i]];
      }
      return all.slice(0, count);
    }

    // chodba od startu ke dve≈ô√≠m, aby hr√°ƒç nebyl zazdƒõn√Ω
    function buildPath(start, end) {
      const path = [];
      let x = start.x;
      let y = start.y;
      while (x !== end.x) {
        x += end.x > x ? 1 : -1;
        path.push({ x, y });
      }
      while (y !== end.y) {
        y += end.y > y ? 1 : -1;
        path.push({ x, y });
      }
      return path;
    }

    function initDungeon() {
      monsters = [];
      chests = [];
      walls = [];
      projectilePath = [];
      projectileType = null;

      player.x = 0;
      player.y = 9;

      const baseForbidden = [{ x: player.x, y: player.y }, exit];

      const corridor = buildPath({ x: player.x, y: player.y }, exit);
      const forbiddenForWalls = baseForbidden.concat(corridor);

      const wallCount = Math.min(20, 6 + level * 2);
      const wallPositions = randomFreePositions(wallCount, forbiddenForWalls);
      walls = wallPositions;

      const forbidden = baseForbidden.concat(walls);

      const monsterCount = Math.min(12, 3 + level * 2);
      const chestCount   = 2 + Math.floor(level / 2);

      const positions = randomFreePositions(monsterCount + chestCount, forbidden);
      const monsterPositions = positions.slice(0, monsterCount);
      const chestPositions   = positions.slice(monsterCount);

      monsterPositions.forEach((pos, i) => {
        const type = MONSTER_TYPES[Math.floor(Math.random() * MONSTER_TYPES.length)];
        const extraHp = (level - 1) * 5;
        const extraAtk = Math.floor((level - 1) / 1.5) + 1;
        monsters.push({
          x: pos.x,
          y: pos.y,
          hp: type.hp + Math.max(0, extraHp),
          attack: type.attack + Math.max(0, extraAtk),
          name: `${type.name} ${i + 1}`,
          symbol: type.symbol
        });
      });

      chestPositions.forEach((pos, i) => {
        chests.push({
          x: pos.x,
          y: pos.y,
          opened: false,
          bonus: 2 + level + i,
          gold: 5 + level * 2 + i * 2
        });
      });

      logEl.innerHTML = "";
      log(`Vstoupil jsi do dungeon runneru ‚Äì level ${level}. Zabij v≈°echna monstra a pak dojdi ke dve≈ô√≠m.`);
    }

    function updatePlayerSymbol() {
      if (player.raceName === 'Elf') {
        player.symbol = 'üßù';
      } else if (player.raceName === 'Ork') {
        player.symbol = 'üßå';
      } else if (player.raceName === 'Trpasl√≠k') {
        player.symbol = 'üßî';
      } else if (player.raceName === 'Hobit') {
        player.symbol = 'üßë';
      } else {
        player.symbol = 'üßë';
      }
    }

    function renderGrid() {
      gridEl.innerHTML = "";
      for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
          const tile = document.createElement('div');
          tile.classList.add('tile');

          let char = '';
          let extraClass = 'empty';

          if (player.x === x && player.y === y) {
            char = player.symbol;
            extraClass = 'player';
          } else if (isWall(x, y)) {
            char = 'üß±';
            extraClass = 'wall';
          } else {
            const m = getMonsterAt(x, y);
            const c = getChestAt(x, y);

            if (m) {
              char = m.symbol;
              extraClass = 'monster';
            } else if (c) {
              char = 'üí∞';
              extraClass = 'chest';
            } else if (exit.x === x && exit.y === y) {
              char = 'üö™';
              extraClass = 'exit';
            } else {
              char = '.';
              extraClass = 'empty';
            }
          }

          if (!(player.x === x && player.y === y) &&
              projectilePath.some(p => p.x === x && p.y === y)) {
            char = projectileType === 'spell' ? '‚úß' : '‚û§';
          }

          tile.textContent = char;
          tile.classList.add(extraClass);
          gridEl.appendChild(tile);
        }
      }
    }

    function endGame(text) {
      gameRunning = false;
      gameOverText.textContent = text;
      gameOverOverlay.style.display = 'flex';
    }

    // ==== pathfinding pro monstra (BFS) ====
    function findNextStepTowards(start, goal) {
      if (start.x === goal.x && start.y === goal.y) return null;

      const dirs = [
        { dx: 1, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: 0, dy: -1 }
      ];

      const visited = Array.from({ length: mapHeight }, () =>
        Array(mapWidth).fill(false)
      );

      const queue = [];
      queue.push({ x: start.x, y: start.y });
      visited[start.y][start.x] = true;

      const parents = {};
      const key = (x, y) => `${x},${y}`;

      while (queue.length > 0) {
        const current = queue.shift();
        if (current.x === goal.x && current.y === goal.y) {
          let k = key(current.x, current.y);
          let prev = parents[k];
          let child = { x: current.x, y: current.y };
          while (prev && !(prev.x === start.x && prev.y === start.y)) {
            child = prev;
            k = key(prev.x, prev.y);
            prev = parents[k];
          }
          return child;
        }

        for (const d of dirs) {
          const nx = current.x + d.dx;
          const ny = current.y + d.dy;
          if (nx < 0 || nx >= mapWidth || ny < 0 || ny >= mapHeight) continue;
          if (visited[ny][nx]) continue;
          if (isWall(nx, ny)) continue;

          const occupied = monsters.some(m => m.hp > 0 &&
            !(m.x === start.x && m.y === start.y) &&
            m.x === nx && m.y === ny);
          if (occupied) continue;

          visited[ny][nx] = true;
          parents[key(nx, ny)] = { x: current.x, y: current.y };
          queue.push({ x: nx, y: ny });
        }
      }
      return null;
    }

    // ==== Pohyb a melee √∫tok ====
    function tryMove(dx, dy) {
      if (!gameRunning) return;
      const newX = player.x + dx;
      const newY = player.y + dy;

      if (newX < 0 || newX >= mapWidth || newY < 0 || newY >= mapHeight) {
        log("Narazil jsi do okraje dungeonu.");
        return;
      }

      if (isWall(newX, newY)) {
        log("Nar√°≈æ√≠≈° do zdi.");
        return;
      }

      const monster = getMonsterAt(newX, newY);
      if (monster) {
        attackMonster(monster);
        return;
      }

      player.x = newX;
      player.y = newY;
      if (dx !== 0 || dy !== 0) {
        player.facing = { dx, dy };
      }
      log(`Posunul ses na (${player.x + 1}, ${player.y + 1}).`);

      const chest = getChestAt(player.x, player.y);
      if (chest) {
        chest.opened = true;
        player.weaponBonus += chest.bonus;
        let goldGain = chest.gold;
        if (player.isThief) {
          goldGain = Math.round(goldGain * THIEF_GOLD_MULTIPLIER);
        }
        gold += goldGain;
        log(`Na≈°el jsi truhlu! Zbra≈à pos√≠lena o +${chest.bonus} √∫toku a z√≠sk√°v√°≈° ${goldGain} zlata.`);
        addItem(`Truhla: +${chest.bonus} √∫toku, ${goldGain} zlata`);
      }

      updateHud();
      renderGrid();

      if (isSamePos(player, exit)) {
        const alive = monsters.some(m => m.hp > 0);
        if (alive) {
          log("Dve≈ôe jsou zamƒçen√©, dokud v dungeonu z≈Øst√°vaj√≠ monstra.");
        } else {
          log("Do≈°el jsi ke dve≈ô√≠m ‚Äì level dokonƒçen!");
          gameRunning = false;
          openShop();
          return;
        }
      }

      monstersAct();
    }

    function rewardGoldForKill(name) {
      let gain = 5 + Math.floor(Math.random() * 6) + level * 2;
      if (player.isThief) {
        gain = Math.round(gain * THIEF_GOLD_MULTIPLIER);
      }
      gold += gain;
      log(`${name} byl pora≈æen! Z√≠sk√°v√°≈° ${gain} zlata.`);
    }

    function attackMonster(monster) {
      if (!gameRunning) return;
      const totalAttack = player.baseAttack + player.weaponBonus;
      log(`√ötoƒç√≠≈° na ${monster.name} a d√°v√°≈° ${totalAttack} po≈°kozen√≠.`);
      monster.hp -= totalAttack;

      if (monster.hp <= 0) {
        rewardGoldForKill(monster.name);
      } else {
        log(`${monster.name} m√° je≈°tƒõ ${monster.hp} HP.`);
      }

      monstersAct();
      updateHud();
      renderGrid();
    }

    function monstersAct() {
      if (!gameRunning) return;
      monsters.forEach(m => {
        if (m.hp <= 0) return;

        const dx = player.x - m.x;
        const dy = player.y - m.y;
        const distance = Math.abs(dx) + Math.abs(dy);

        if (distance === 1) {
          // zp≈ô√≠snƒõn√° obrana ‚Äì obrana m√° men≈°√≠ efekt, dmg nikdy neklesne pod 1
          const raw = m.attack - Math.floor(player.defense * 0.6);
          const dmg = Math.max(1, raw);
          player.hp -= dmg;
          log(`${m.name} tƒõ zas√°hl za ${dmg} po≈°kozen√≠!`);
          if (player.hp <= 0) {
            player.hp = 0;
            updateHud();
            endGame("Zem≈ôel jsi v dungeonu. :(");
          }
        } else {
          const nextStep = findNextStepTowards({ x: m.x, y: m.y }, { x: player.x, y: player.y });
          if (nextStep) {
            const occupied = monsters.some(other => other !== m && other.hp > 0 &&
              other.x === nextStep.x && other.y === nextStep.y);
            if (!occupied && !(player.x === nextStep.x && player.y === nextStep.y)) {
              m.x = nextStep.x;
              m.y = nextStep.y;
            }
          }
        }
      });
      updateHud();
      renderGrid();
    }

    // Ability 1 ‚Äì mal√© l√©ƒçen√≠
    function useAbility1() {
      if (!gameRunning) return;
      const heal = 4;
      if (player.hp >= player.maxHp) {
        log("Ability 1: U≈æ m√°≈° pln√© ≈æivoty.");
        return;
      }
      player.hp = Math.min(player.maxHp, player.hp + heal);
      log(`Ability 1: L√©ƒç√≠≈° se o ${heal} HP.`);
      updateHud();
    }

    // Line-of-sight pro ranged (kontrola zd√≠)
    function hasLineOfSightTo(target) {
      if (target.x !== player.x && target.y !== player.y) return false;
      let dx = 0, dy = 0;
      if (target.x > player.x) dx = 1;
      else if (target.x < player.x) dx = -1;
      if (target.y > player.y) dy = 1;
      else if (target.y < player.y) dy = -1;

      let x = player.x + dx;
      let y = player.y + dy;
      while (!(x === target.x && y === target.y)) {
        if (isWall(x, y)) return false;
        x += dx;
        y += dy;
      }
      return true;
    }

    // Najdi nejbli≈æ≈°√≠ c√≠l pro ranged (v ≈ôadƒõ/sloupci, vzd√°lenost 2‚Äì4)
    function findRangedTarget(maxRange = 4) {
      let best = null;
      monsters.forEach(m => {
        if (m.hp <= 0) return;
        if (m.x !== player.x && m.y !== player.y) return; // mus√≠ b√Ωt v ≈ôadƒõ nebo sloupci
        const dist = Math.abs(m.x - player.x) + Math.abs(m.y - player.y);
        if (dist < 2 || dist > maxRange) return;
        if (!hasLineOfSightTo(m)) return;
        if (!best || dist < best.dist) {
          let dx = 0, dy = 0;
          if (m.x > player.x) dx = 1;
          else if (m.x < player.x) dx = -1;
          if (m.y > player.y) dy = 1;
          else if (m.y < player.y) dy = -1;
          best = { monster: m, dx, dy, dist };
        }
      });
      return best;
    }

    // √ötok na d√°lku ‚Äì auto-target
    function useRangedAttack() {
      if (!gameRunning) return;

      let dmg;
      let type = null;

      if (player.archetype === 'M√°g') {
        const cost = 3;
        if (player.mana < cost) {
          log("Nem√°≈° dost many na kouzlo na d√°lku.");
          return;
        }
        player.mana -= cost;
        dmg = player.baseAttack + player.weaponBonus + 4;
        type = 'spell';
        log("Ses√≠l√°≈° kouzlo na d√°lku.");
      } else if (player.archetype === 'Luƒçi≈°tn√≠k') {
        const cost = 1;
        if (player.arrows < cost) {
          log("Do≈°ly ti ≈°√≠py.");
          return;
        }
        player.arrows -= cost;
        dmg = player.baseAttack + player.weaponBonus + 3;
        type = 'arrow';
        log("Vyst≈ôelil jsi ≈°√≠p.");
      } else {
        log("Tvoje postava nem√° √∫tok na d√°lku.");
        return;
      }

      const targetInfo = findRangedTarget(4);
      if (!targetInfo) {
        log("V dosahu (2‚Äì4 pol√≠ v ≈ôadƒõ/sloupci) nen√≠ ≈æ√°dn√Ω c√≠l.");
        updateHud();
        return;
      }

      const { monster: target, dx, dy, dist } = targetInfo;

      let x = player.x + dx;
      let y = player.y + dy;
      let pathCells = [];

      for (let step = 1; step <= dist; step++) {
        pathCells.push({ x, y });
        x += dx;
        y += dy;
      }

      projectilePath = pathCells;
      projectileType = type;
      updateHud();
      renderGrid();

      gameRunning = false;

      setTimeout(() => {
        log(`√ötok na d√°lku zasahuje ${target.name} za ${dmg} po≈°kozen√≠.`);
        target.hp -= dmg;
        if (target.hp <= 0) {
          rewardGoldForKill(target.name);
        } else {
          log(`${target.name} m√° je≈°tƒõ ${target.hp} HP.`);
        }

        projectilePath = [];
        projectileType = null;
        updateHud();
        renderGrid();

        gameRunning = true;
        monstersAct();
      }, 180);
    }

    // ==== Obchod ====
    function openShop() {
      shopInfo.textContent = `Level ${level} dokonƒçen. M√°≈° ${gold} zlata. Vyber si vylep≈°en√≠ nebo pokraƒçuj d√°l.`;
      updateShopButtons();
      shopOverlay.style.display = 'flex';
      updateHud();
    }

    shopItems.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON') return;
      const action = e.target.dataset.action;
      let cost = 0;

      if (action === 'hp') {
        cost = shopCosts.hp;
        if (gold >= cost) {
          gold -= cost;
          player.maxHp += 5;
          player.hp += 5;
          shopCosts.hp = Math.round(shopCosts.hp * SHOP_INFLATION);
          log("Kupuje≈°: +5 max HP (cena p≈ô√≠≈°tƒõ vy≈°≈°√≠).");
          addItem("+5 max HP (obchod)");
        } else {
          log("Nem√°≈° dost zlata na +5 max HP.");
        }
      } else if (action === 'atk') {
        cost = shopCosts.atk;
        if (gold >= cost) {
          gold -= cost;
          player.baseAttack += 2;
          shopCosts.atk = Math.round(shopCosts.atk * SHOP_INFLATION);
          log("Kupuje≈°: +2 z√°kladn√≠ √∫tok (cena p≈ô√≠≈°tƒõ vy≈°≈°√≠).");
          addItem("+2 z√°kladn√≠ √∫tok (obchod)");
        } else {
          log("Nem√°≈° dost zlata na +2 √∫tok.");
        }
      } else if (action === 'def') {
        cost = shopCosts.def;
        if (gold >= cost) {
          gold -= cost;
          // v√°leƒçn√≠k tƒõ≈æ√≠ z obrany v√≠c ‚Äì mal√© zv√Ω≈°en√≠ bonusu
          const bonus = (player.archetype === 'V√°leƒçn√≠k') ? 2 : 1;
          player.defense += bonus;
          shopCosts.def = Math.round(shopCosts.def * SHOP_INFLATION);
          log(`Kupuje≈°: +${bonus} obrana (cena p≈ô√≠≈°tƒõ vy≈°≈°√≠).`);
          addItem(`+${bonus} obrana (obchod)`);
        } else {
          log("Nem√°≈° dost zlata na +1 obranu.");
        }
      } else if (action === 'heal') {
        cost = shopCosts.heal;
        if (gold >= cost) {
          gold -= cost;
          player.hp = player.maxHp;
          shopCosts.heal = Math.round(shopCosts.heal * SHOP_INFLATION);
          log("Kupuje≈°: pln√© l√©ƒçen√≠ (cena p≈ô√≠≈°tƒõ vy≈°≈°√≠).");
        } else {
          log("Nem√°≈° dost zlata na l√©ƒçen√≠.");
        }
      }

      shopInfo.textContent = `Level ${level} dokonƒçen. M√°≈° ${gold} zlata.`;
      updateShopButtons();
      updateHud();
    });

    nextLevelBtn.addEventListener('click', () => {
      level += 1;
      player.hp = player.maxHp;
      if (player.archetype === 'M√°g') {
        player.mana = player.maxMana;
      }
      if (player.archetype === 'Luƒçi≈°tn√≠k') {
        player.arrows += 3;
      }
      shopOverlay.style.display = 'none';
      startLevel();
    });

    // ==== Obsluha kl√°ves ====
    window.addEventListener('keydown', (e) => {
      if (!gameRunning) return;

      keyPressCount++;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',
           'w','W','a','A','s','S','d','D',' ','1','2'].includes(e.key)) {
        e.preventDefault();
      }

      switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          tryMove(0, -1);
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          tryMove(0, 1);
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          tryMove(-1, 0);
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          tryMove(1, 0);
          break;
        case '1':
          useAbility1();
          break;
        case '2':
          useRangedAttack();
          break;
        case ' ': {
          const neighbors = [
            { x: player.x + 1, y: player.y },
            { x: player.x - 1, y: player.y },
            { x: player.x, y: player.y + 1 },
            { x: player.x, y: player.y - 1 }
          ];
          const target = neighbors
            .map(pos => getMonsterAt(pos.x, pos.y))
            .find(m => m);
          if (target) {
            attackMonster(target);
          } else {
            log("≈Ω√°dn√© monstrum v dosahu √∫toku.");
          }
          break;
        }
      }
      updateHud();
    });

    // ==== Start levelu ====
    function startLevel() {
      initDungeon();
      updateHud();
      renderGrid();
      gameRunning = true;
    }

    // ==== Start hry z menu ====
    document.getElementById('startGame').addEventListener('click', () => {
      const raceValue = document.getElementById('raceSelect').value;

      player.isThief = false;
      player.items = [];
      updateInventory();

      if (raceValue === 'human') {
        player.raceName = 'ƒålovƒõk';
        player.archetype = 'M√°g';
        player.maxHp = 20;
        player.baseAttack = 7;
        player.defense = 0;
        player.maxMana = 12;
        player.mana = 12;
        player.arrows = 0;
      } else if (raceValue === 'elf') {
        player.raceName = 'Elf';
        player.archetype = 'Luƒçi≈°tn√≠k';
        player.maxHp = 22;
        player.baseAttack = 6;
        player.defense = 0;
        player.maxMana = 0;
        player.mana = 0;
        player.arrows = 7;
      } else if (raceValue === 'dwarf') {
        player.raceName = 'Trpasl√≠k';
        player.archetype = 'V√°leƒçn√≠k';
        player.maxHp = 32;
        player.baseAttack = 6;
        player.defense = 3;   // lep≈°√≠ zbroj
        player.maxMana = 0;
        player.mana = 0;
        player.arrows = 0;
      } else if (raceValue === 'hobbit') {
        player.raceName = 'Hobit';
        player.archetype = 'Zlodƒõj';
        player.maxHp = 24;
        player.baseAttack = 5;
        player.defense = 1;
        player.maxMana = 0;
        player.mana = 0;
        player.arrows = 0;
        player.isThief = true;
      }

      player.hp = player.maxHp;
      player.weaponBonus = 0;
      player.facing = { dx: 1, dy: 0 };
      updatePlayerSymbol();

      level = 1;
      gold = 0;
      keyPressCount = 0;

      shopCosts.hp = 10;
      shopCosts.atk = 10;
      shopCosts.def = 8;
      shopCosts.heal = 6;

      gameOverOverlay.style.display = 'none';
      shopOverlay.style.display = 'none';

      menuEl.classList.add('hidden');
      gameEl.classList.remove('hidden');

      startLevel();
    });

    document.getElementById('restartBtn').addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      gameEl.classList.add('hidden');
      menuEl.classList.remove('hidden');
    });
  </script>
</body>
</html>
